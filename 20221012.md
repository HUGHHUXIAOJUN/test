## 01背包

> 给定n种物品和一个容量为j的背包，物品i的重量是wi,价值是vi，
> 问： 应该如何选择装入背包的物品，使得装入背包的物品价值最大

## 01背包所讲的是 每个物品只有一个，完全背包问题是物品有无限个，多重背包问题是第i个物品有k个(每个物品个数不同)

> 大家都知道用动态规划来解决问题，现在我们做一个假设，通过实际案列来找规律, 一个表格横向表示背包的重量，竖向表示物品个数，穷举来算出第n个物品背包重量j下的最大价值，下表左边两个竖列表示物品的重量和价值，我们预留了背包容量为0数量为0的可选项，主要防止越界，问题需要知道i-1的情况保证i-1不为负数，

> 其实斜体是不为0的真实情况，以背包容量为10的时候为例能放下的最大价值？物品重量不超过背包，当只有一个物品的时候是2种情况，我放进去最大价值就是放入物品的价值，不放进去价值就是0，如果物品超过背包的重量那就是不放的价值这时候最大价值就是0个物品的时候。以下表为例当有4个物品的时候，有多种情况，1️⃣我什么都不放，价值02️⃣我都放第一个物品(重量2价值1)，可以放5个价值53️⃣我都放第二个物品(重量3价值3)，放3个剩余1，价值94️⃣...这时候其实比较简单我们可以得出最大价值就是第四个物品(重量7价值9)和第二个物品(重量3价值3)放入背包刚好把背包放满价值12

> 那么价值12这个用竖向是表示第4个物品如果我们不放入背包，那么这时候和只有三个物品价值是一样的，如果放入物品，背包剩下的空间就是背包空间10-第四个物品的重量7，这个时候背包空间剩下3就和我们背包空间3有4个物品的情况一样;

```js
// 表格用二维dp数组表示要计算出重量为j物品有n个的最大价值
if('放不进背包'){
    // 这个物品不放入背包的价值，就是少一个物品同样重量的值
    dp[n][j] = dp[n-1][j]
}else{
    // 放入背包 物品都只有1个所以 物品-1  这个时候背包容量就是 j-wi[n] 价值为下
    dp[n][j] = vi[n] + dp[n-1][j-wi[n]]
    // 这里要考虑下是放入的价值，但是放入并不一定价值最大 和不放入的时候价值比较下
    dp[n][j] = Math.max(dp[n-1][j],vi[n] + dp[n-1][j-wi[n]])
}
// 所以我们要知道这个最大价值只要重背包0价值0来一步步推就能得到想要的结果
function getMaxValue(n,j,w,v){
    let dp = new Array(n+1).fill().map(() => new Array(j+1).fill(0))
    for(let i=1; i<=n; i++){
        for(let m=1; m<=j; m++){
            if(m<w[i]){
                //不能放入背包
                dp[i][m] = dp[i-1][m]
            }else{
                dp[i][m] = Math.max(dp[i-1][m],dp[i-1][m-w[i]]+v[i])
            }
        }
    }
    return dp
}
let w = [0,2,3,4,7];
let v = [0,1,3,5,9];
let val = getMaxValue(4,10,w,v)
console.log(val)
```


wi  |  vi|   0|   1|   2|   3|   4|   5|   6|   7|   8|   9|  10|
:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
0   |   0|   0|   0|   0|   0|   0|   0|   0|   0|   0|   0|   0|
:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
2   |   1|   0| *0*| *1*| *1*| *1*| *1*| *1*| *1*| *1*| *1*| *1*|
:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
3   |   3|   0| *1*| *3*| *3*| *4*| *4*| *4*| *4*| *4*| *4*| *4*|
:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
4   |   5|   0| *0*| *1*| *3*| *5*| *5*| *6*| *8*| *8*| *9*| *9*|
:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
7   |   9|   0| *0*| *1*| *3*| *5*| *5*| *6*| *9*| *9*|*10*|*12*|
:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|

> 如果不需要回溯放了那些物品 代码还可以继续优化，因为我们知道最终结果只和上一次的数组有关，我们只需要知道n-1的时候数组就可以，n为1的时候物品就是0个

```js
function getMaxValue(n,j,w,v){
    let dp = new Array(j+1).fill(0)
    for(let i=1; i<=n; i++){
        for(let m=j; m>=w[i]; m--){ // 判断直接放的下进行 放不下就是上一个最初的就是[0,0,0,0,0]
            // 当二维数组存在的时候正反遍历都可以，但一维的时候需要用到之前的值，不能让之前的值变更最新的，需要反向遍历
            // 这边只有放的下的时候才会覆盖上一个值，不然保持不变，放不下就不用写入了
            dp[m] = Math.max(dp[m],dp[m-w[i]] + v[i])
        }
    }
    return dp
}

```

## 完全背包 物品可以有n个
```js
function getMaxValue(n,j,w,v){
    let dp = new Array(n+1).fill().map(() => new Array(j+1).fill(0))
    for(let i=1; i<=n; i++){
        for(let m=1; m<=j; m++){
            // 这边计算下最多放下当前物品的个数，第二个比较的不是dp[i-1][m-k*w[i]]+k*v[i]
            // 而是 dp[i][m-k*w[i]]+k*v[i] 因为物品放入可以继续放和不放01背包是放了就不能放了
            for(let k=0;k<=m/w[i];k++){
                dp[i][m] = Math.max(dp[i-1][m],dp[i][m-k*w[i]]+k*v[i])
            }
        }
    }
    return dp
}
// 继续优化之后
function getMaxValue(n,j,w,v){
    let dp = new Array(j+1).fill(0)
    for(let i=1; i<=n; i++){
        for(let m=w[i]; m<=j; m++){
            // 正向遍历，价值比较是本行新值去对比
            dp[m] = Math.max(dp[m],dp[m-w[i]] + v[i])
        }
    }
    return dp
}
```
## 多重背包

> 这个时候物品多了一个限制, 其实就是完全背包k不仅仅是 k<=m/w[i]&& k<当前物品的个数

> 代码优化简写就是 dp[m] = Math.max(dp[m],dp[m-w[i]] + v[i])
